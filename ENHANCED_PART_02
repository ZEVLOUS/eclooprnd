      size_t g_idx = positive ? 0 : hsize;
      size_t g_max = positive ? hsize - 1 : hsize;
      for (size_t i = 0; i < g_max; ++i) {
        fe_modp_sub(ss, ctx->gpoints[g_idx + i].y, GStart.y);
        fe_modp_mul(ss, ss, dx[i]);
        fe_modp_sqr(rx, ss);
        fe_modp_sub(rx, rx, GStart.x);
        fe_modp_sub(rx, rx, ctx->gpoints[g_idx + i].x);
        fe_modp_sub(dd, GStart.x, rx);
        fe_modp_mul(dd, ss, dd);
        fe_modp_sub(ry, dd, GStart.y);

        size_t idx = positive ? hsize + i + 1 : hsize - 1 - i;
        fe_clone(bp[idx].x, rx);
        fe_clone(bp[idx].y, ry);
        fe_set64(bp[idx].z, 0x1);
      }
    }

    check_found_scan(ctx, ck, bp);
    
    // Update display with current key
    ctx_scan_update(ctx, GROUP_INV_SIZE, ck);
    
    // IMMEDIATE exit check after update
    if (ctx->finished) return;
    
    fe_modn_add_stride(ck, ck, ctx->stride_k, GROUP_INV_SIZE);
    ec_jacobi_addrdc(&GStart, &GStart, &ctx->stride_p);
    counter += GROUP_INV_SIZE;
  }
}

void *cmd_scan_worker(void *arg) {
  ctx_t *ctx = (ctx_t *)arg;

  fe initial_r;
  fe_clone(initial_r, ctx->range_s);

  fe inc = {0};
  fe_set64(inc, ctx->job_size);
  fe_modn_mul(inc, inc, ctx->stride_k);

  fe pk;
  while (!ctx->finished) {
    pthread_mutex_lock(&ctx->lock);
    bool is_overflow = fe_cmp(ctx->range_s, initial_r) < 0;
    if (fe_cmp(ctx->range_s, ctx->range_e) >= 0 || is_overflow) {
      pthread_mutex_unlock(&ctx->lock);
      break;
    }

    fe_clone(pk, ctx->range_s);
    fe_modn_add(ctx->range_s, ctx->range_s, inc);
    pthread_mutex_unlock(&ctx->lock);

    batch_scan(ctx, pk, ctx->job_size);
    
    // Stop if key found
    if (ctx->stop_on_found && ctx->k_found > 0) {
      break;
    }
  }

  return NULL;
}

void load_session(ctx_t *ctx) {
  if (strlen(ctx->session_file) > 0 && ctx->load_session) {
    FILE *f = fopen(ctx->session_file, "r");
    if (f) {
      char line[128];
      if (fgets(line, sizeof(line), f)) {
        fe_modn_from_hex(ctx->range_s, line);
        fprintf(stderr, "[SESSION] Resumed from: %s", line);
      }
      if (fgets(line, sizeof(line), f)) {
        ctx->k_checked = strtoull(line, NULL, 10);
        fprintf(stderr, "[SESSION] Previous keys scanned: %llu\n", 
                (unsigned long long)ctx->k_checked);
      }
      fclose(f);
    }
  }
}

void cmd_scan(ctx_t *ctx) {
  ctx->stop_on_found = true;
  
  // Initialize matrix display
  for (int i = 0; i < 10; i++) {
    ctx->matrix_keys[i][0] = '\0';
  }
  
  // Initialize enhanced features
  ctx->last_k_checked = 0;
  ctx->last_k_timestamp = tsnow();
  fe_set64(ctx->current_scan_pos, 0);
  
  // Load session if requested
  load_session(ctx);
  
  // Calculate total range
  fe range_size;
  fe_modn_sub(range_size, ctx->range_e, ctx->range_s);
  ctx->scan_total_range = range_size[0];
  
  // Silent startup - no logs, go straight to scanning
  
  ctx_precompute_gpoints(ctx);

  fe_modn_sub(range_size, ctx->range_e, ctx->range_s);
  ctx->job_size = fe_cmp64(range_size, MAX_JOB_SIZE) < 0 ? range_size[0] : MAX_JOB_SIZE;
  ctx->ts_started = tsnow();
  ctx->ts_printed = ctx->ts_started;

  draw_matrix_scanner(ctx);

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_create(&ctx->threads[i], NULL, cmd_scan_worker, ctx);
  }

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_join(ctx->threads[i], NULL);
  }

  pthread_mutex_lock(&ctx->lock);
  ctx->finished = true;
  pthread_mutex_unlock(&ctx->lock);
  
  // Calculate final metrics
  int64_t effective_time = (int64_t)(tsnow() - ctx->ts_started) - (int64_t)ctx->paused_time;
  double elapsed_sec = MAX(1, effective_time) / 1000.0;
  double avg_kps = ctx->k_checked / elapsed_sec / 1000000;
  
  int elapsed_hours = (int)(elapsed_sec / 3600);
  int elapsed_mins = (int)((elapsed_sec - elapsed_hours * 3600) / 60);
  int elapsed_secs = (int)(elapsed_sec - elapsed_hours * 3600 - elapsed_mins * 60);
  
  // Clear screen for final message
  printf("\033[2J\033[H");
  
  if (ctx->k_found > 0) {
    // Audio notification (beep)
    if (ctx->enable_beep) {
      printf("\a\a\a"); // ASCII bell character (3 beeps)
      fflush(stdout);
    }
    
    printf("\n");
    printf("\033[1;32m╔════════════════════════════════════════════════════════════════╗\033[0m\n");
    printf("\033[1;32m║                      [ KEY FOUND ]                             ║\033[0m\n");
    printf("\033[1;32m╚════════════════════════════════════════════════════════════════╝\033[0m\n");
    printf("\n");
    
    if (strlen(ctx->matrix_keys[0]) > 0) {
      printf("\033[1;33m0x%s\033[0m\n", ctx->matrix_keys[0]);
    }
    
    if (ctx->outfile != NULL) {
      fflush(ctx->outfile);
      fclose(ctx->outfile);
      printf("\033[1;32m✓\033[0m Result saved to output file\n");
    }
    
    printf("\033[1;36mTime elapsed:\033[0m %02d:%02d:%02d\n", elapsed_hours, elapsed_mins, elapsed_secs);
    printf("\033[1;36mTotal scanned:\033[0m %'llu keys\n", (unsigned long long)ctx->k_checked);
    printf("\033[1;36mAverage speed:\033[0m %.2f MKeys/s\n", avg_kps);
    printf("\033[1;32mExiting...\033[0m\n");
    fflush(stdout);
    
    // Clean up session file on success
    if (strlen(ctx->session_file) > 0) {
      remove(ctx->session_file);
    }
    
    // Close log file
    if (ctx->logfile != NULL) {
      fprintf(ctx->logfile, "[SUCCESS] Key found: 0x%s\n", ctx->matrix_keys[0]);
      fprintf(ctx->logfile, "[SUCCESS] Total scanned: %llu keys\n", 
              (unsigned long long)ctx->k_checked);
      fclose(ctx->logfile);
    }
    
    exit(0);
  } else {
    printf("\n\033[1;33mScan complete. No keys found.\033[0m\n");
    printf("Time elapsed: %02d:%02d:%02d\n", elapsed_hours, elapsed_mins, elapsed_secs);
    printf("Total scanned: %'llu keys\n", (unsigned long long)ctx->k_checked);
    printf("Average speed: %.2f MKeys/s\n", avg_kps);
    fflush(stdout);
    
    if (ctx->outfile != NULL) fclose(ctx->outfile);
    if (ctx->logfile != NULL) fclose(ctx->logfile);
  }
}
// MARK: args helpers

void arg_search_range(args_t *args, fe range_s, fe range_e) {
  char *raw = arg_str(args, "-r");
  if (!raw) {
    fe_set64(range_s, GROUP_INV_SIZE);
    fe_clone(range_e, FE_P);
    return;
  }

  char *sep = strchr(raw, ':');
  if (!sep) {
    fprintf(stderr, "invalid search range, use format: -r 8000:ffff\n");
    exit(1);
  }

  *sep = 0;
  fe_modn_from_hex(range_s, raw);
  fe_modn_from_hex(range_e, sep + 1);

  // if (fe_cmp64(range_s, GROUP_INV_SIZE) <= 0) fe_set64(range_s, GROUP_INV_SIZE + 1);
  // if (fe_cmp(range_e, FE_P) > 0) fe_clone(range_e, FE_P);

  if (fe_cmp64(range_s, GROUP_INV_SIZE) <= 0) {
    fprintf(stderr, "invalid search range, start <= %#lx\n", GROUP_INV_SIZE);
    exit(1);
  }

  if (fe_cmp(range_e, FE_P) > 0) {
    fprintf(stderr, "invalid search range, end > FE_P\n");
    exit(1);
  }

  if (fe_cmp(range_s, range_e) >= 0) {
    fprintf(stderr, "invalid search range, start >= end\n");
    exit(1);
  }
}

void load_offs_size(ctx_t *ctx, args_t *args) {
  const u32 MIN_SIZE = 20;
  const u32 MAX_SIZE = 64;

  u32 range_bits = fe_bitlen(ctx->range_e);
  u32 default_bits = range_bits < 32 ? MAX(MIN_SIZE, range_bits) : 32;
  u32 max_offs = MAX(1ul, MAX(MIN_SIZE, range_bits) - default_bits);

  char *raw = arg_str(args, "-d");
  if (!raw && ctx->cmd == CMD_RND) {
    ctx->ord_offs = rand64(!ctx->has_seed) % max_offs;
    ctx->ord_size = default_bits;
    return;
  }

  if (!raw) {
    ctx->ord_offs = 0;
    ctx->ord_size = default_bits;
    return;
  }

  char *sep = strchr(raw, ':');
  if (!sep) {
    fprintf(stderr, "invalid offset:size format, use format: -d 128:32\n");
    exit(1);
  }

  *sep = 0;
  u32 tmp_offs = atoi(raw);
  u32 tmp_size = atoi(sep + 1);

  if (tmp_offs > 255) {
    fprintf(stderr, "invalid offset, max is 255\n");
    exit(1);
  }

  // Allow bits == 0 for pure random mode, otherwise enforce MIN_SIZE
  if (tmp_size == 0) {
    // Pure random mode: -d 0:0
    ctx->ord_offs = 0;
    ctx->ord_size = 0;
    return;
  }

  if (tmp_size < MIN_SIZE || tmp_size > MAX_SIZE) {
    fprintf(stderr, "invalid size, min is %d and max is %d (or 0 for pure random mode)\n", MIN_SIZE, MAX_SIZE);
    exit(1);
  }

  ctx->ord_offs = MIN(max_offs, tmp_offs);
  ctx->ord_size = tmp_size;
}

// MARK: main

void usage(const char *name) {
  printf("Usage: %s <cmd> [-t <threads>] [-f <file>] [-a <addr_type>] [-r <range>]\n", name);
  printf("v%s ~ https://github.com/vladkens/ecloop\n", VERSION);
  printf("\nCompute commands:\n");
  printf("  add             - search in given range with batch addition\n");
  printf("  mul             - search hex encoded private keys (from stdin)\n");
  printf("  rnd             - search random range of bits in given range\n");
  printf("  scan            - custom Bitcoin scanner with Matrix-style UI\n");
  printf("\nCompute options:\n");
  printf("  -f <file>       - filter file to search (list of hashes or bloom fitler)\n");
  printf("  -o <file>       - output file to write found keys (default: stdout)\n");
  printf("  -t <threads>    - number of threads to run (default: 1)\n");
  printf("  -a <addr_type>  - address type to search: c - addr33, u - addr65 (default: c)\n");
  printf("  -r <range>      - search range in hex format (example: 8000:ffff, default all)\n");
  printf("  -d <offs:size>  - bit offset and size for search (example: 128:32, default: 0:32)\n");
  printf("                    use -d 0:0 for pure random mode (no chunking)\n");
  printf("  -q              - quiet mode (no output to stdout; -o required)\n");
  printf("  -endo           - use endomorphism (default: false)\n");
  printf("\nScan command enhanced options:\n");
  printf("  --beep          - enable audio notification on key found\n");
  printf("  --log <file>    - write detailed scan log to file\n");
  printf("  --session <file>- save/resume scan position (use with Ctrl+C)\n");
  printf("  --resume        - resume from last saved session\n");
  printf("\nOther commands:\n");
  printf("  blf-gen         - create bloom filter from list of hex-encoded hash160\n");
  printf("  blf-check       - check bloom filter for given hex-encoded hash160\n");
  printf("  bench           - run benchmark of internal functions\n");
  printf("  bench-gtable    - run benchmark of ecc multiplication (with different table size)\n");
  printf("\n");
}

void init(ctx_t *ctx, args_t *args) {
  // check other commands first
  if (args->argc > 1) {
    if (strcmp(args->argv[1], "blf-gen") == 0) return blf_gen(args);
    if (strcmp(args->argv[1], "blf-check") == 0) return blf_check(args);
    if (strcmp(args->argv[1], "bench") == 0) return run_bench();
    if (strcmp(args->argv[1], "bench-gtable") == 0) return run_bench_gtable();
    if (strcmp(args->argv[1], "mult-verify") == 0) return mult_verify();
  }

  ctx->use_color = isatty(fileno(stdout));

  ctx->cmd = CMD_NIL; // default show help
  if (args->argc > 1) {
    if (strcmp(args->argv[1], "add") == 0) ctx->cmd = CMD_ADD;
    if (strcmp(args->argv[1], "mul") == 0) ctx->cmd = CMD_MUL;
    if (strcmp(args->argv[1], "rnd") == 0) ctx->cmd = CMD_RND;
    if (strcmp(args->argv[1], "scan") == 0) ctx->cmd = CMD_SCAN;
  }

  if (ctx->cmd == CMD_NIL) {
    if (args_bool(args, "-v")) printf("ecloop v%s\n", VERSION);
    else usage(args->argv[0]);
    exit(0);
  }

  ctx->has_seed = false;
  char *seed = arg_str(args, "-seed");
  if (seed != NULL) {
    ctx->has_seed = true;
    srand(encode_seed(seed));
    free(seed);
  }

  char *path = arg_str(args, "-f");
  load_filter(ctx, path);

  ctx->quiet = args_bool(args, "-q");
  char *outfile = arg_str(args, "-o");
  if (outfile) ctx->outfile = fopen(outfile, "a");

  if (outfile == NULL && ctx->quiet) {
    fprintf(stderr, "quiet mode chosen without output file\n");
    exit(1);
  }

  char *addr = arg_str(args, "-a");
  if (addr) {
    ctx->check_addr33 = strstr(addr, "c") != NULL;
    ctx->check_addr65 = strstr(addr, "u") != NULL;
  }

  if (!ctx->check_addr33 && !ctx->check_addr65) {
    ctx->check_addr33 = true; // default to addr33
  }

  ctx->use_endo = args_bool(args, "-endo");
  if (ctx->cmd == CMD_MUL) ctx->use_endo = false; // no endo for mul command

  pthread_mutex_init(&ctx->lock, NULL);
  int cpus = get_cpu_count();
  ctx->threads_count = MIN(MAX(args_uint(args, "-t", cpus), 1ul), 320ul);
  ctx->threads = malloc(ctx->threads_count * sizeof(pthread_t));
  ctx->finished = false;
  ctx->k_checked = 0;
  ctx->k_found = 0;
  ctx->ts_started = tsnow();
  ctx->ts_updated = ctx->ts_started;
  ctx->ts_printed = ctx->ts_started - 5e3;
  ctx->paused_time = 0;
  ctx->paused = false;

  arg_search_range(args, ctx->range_s, ctx->range_e);
  load_offs_size(ctx, args);
  queue_init(&ctx->queue, ctx->threads_count * 3);

  // Enable KeyHunt-style view for pure random mode (-d 0:0)
  ctx->pure_random_view = (ctx->ord_size == 0 && ctx->cmd == CMD_RND);
  ctx->tid = 0; // Main thread is 0
  
  // Initialize sample_key
  snprintf(ctx->sample_key, sizeof(ctx->sample_key), 
           "0000000000000000000000000000000000000000000000000000000000000000");

  // Silent mode - no initialization output
  
  if (ctx->cmd == CMD_MUL) {
    ctx->raw_text = args_bool(args, "-raw");
  }
  
  // Initialize scan mode fields
  ctx->target_address[0] = '\0';
  ctx->stop_on_found = false;
  ctx->matrix_index = 0;
  ctx->scan_total_range = 0;
  
  // Enhanced features initialization
  ctx->enable_beep = args_bool(args, "--beep");
  ctx->load_session = args_bool(args, "--resume");
  ctx->logfile = NULL;
  ctx->session_file[0] = '\0';
  
  // Log file (scan command only)
  if (ctx->cmd == CMD_SCAN) {
    char *logfile = arg_str(args, "--log");
    if (logfile) {
      ctx->logfile = fopen(logfile, "a");
      if (ctx->logfile) {
        fprintf(ctx->logfile, "\n[START] Scan started at timestamp %llu\n", (unsigned long long)tsnow());
        fprintf(ctx->logfile, "[CONFIG] Threads: %zu\n", ctx->threads_count);
        fprintf(ctx->logfile, "[CONFIG] Range: %016llx%016llx -> %016llx%016llx\n",
                ctx->range_s[3], ctx->range_s[2], ctx->range_e[3], ctx->range_e[2]);
        fflush(ctx->logfile);
      }
    }
    
    // Session file (scan command only)
    char *sessionfile = arg_str(args, "--session");
    if (sessionfile) {
      strncpy(ctx->session_file, sessionfile, sizeof(ctx->session_file) - 1);
    } else if (ctx->load_session) {
      // Default session file if --resume is used without --session
      snprintf(ctx->session_file, sizeof(ctx->session_file), ".eclooprnd_session.dat");
    }
  }
}

// Global context pointer for signal handler
static ctx_t *global_ctx = NULL;

void handle_sigint(int sig) {
  fflush(stderr);
  fflush(stdout);
  printf("\n");
  
  // Save session before exit
  if (global_ctx != NULL && global_ctx->cmd == CMD_SCAN) {
    save_session(global_ctx);
    printf("\033[1;33m[SESSION] Progress saved to: %s\033[0m\n", global_ctx->session_file);
    printf("\033[1;33m[SESSION] Resume with: --session %s --resume\033[0m\n", global_ctx->session_file);
    
    if (global_ctx->logfile != NULL) {
      fprintf(global_ctx->logfile, "[INTERRUPT] Scan interrupted by user\n");
      fprintf(global_ctx->logfile, "[INTERRUPT] Keys scanned: %llu\n", 
              (unsigned long long)global_ctx->k_checked);
      fclose(global_ctx->logfile);
    }
  }
  
  exit(sig);
}

void tty_cb(void *ctx_raw, const char ch) {
  ctx_t *ctx = (ctx_t *)ctx_raw;

  if (ch == 'p' && !ctx->paused) {
    ctx->ts_paused_at = tsnow();
    ctx->paused = true;
    ctx_print_status(ctx);
  }

  if (ch == 'r' && ctx->paused) {
    ctx->paused_time += tsnow() - ctx->ts_paused_at;
    ctx->paused = false;
    ctx_print_status(ctx);
  }
}

int main(int argc, const char **argv) {
  // https://stackoverflow.com/a/11695246
  setlocale(LC_NUMERIC, ""); // for comma separated numbers
  args_t args = {argc, argv};

  ctx_t ctx = {0};
  init(&ctx, &args);

  signal(SIGINT, handle_sigint); // Keep last progress line on Ctrl-C
  tty_init(tty_cb, &ctx);        // override tty to handle pause/resume

