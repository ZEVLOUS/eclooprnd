
void cmd_add(ctx_t *ctx) {
  ctx_precompute_gpoints(ctx);

  fe range_size;
  fe_modn_sub(range_size, ctx->range_e, ctx->range_s);
  ctx->job_size = fe_cmp64(range_size, MAX_JOB_SIZE) < 0 ? range_size[0] : MAX_JOB_SIZE;
  ctx->ts_started = tsnow(); // actual start time

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_create(&ctx->threads[i], NULL, cmd_add_worker, ctx);
  }

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_join(ctx->threads[i], NULL);
  }

  ctx_finish(ctx);
}

// MARK: CMD_MUL

void check_found_mul(ctx_t *ctx, const fe *pk, const pe *cp, size_t cnt) {
  h160_t hs33[HASH_BATCH_SIZE];
  h160_t hs65[HASH_BATCH_SIZE];

  for (size_t i = 0; i < cnt; i += HASH_BATCH_SIZE) {
    size_t batch_size = MIN(HASH_BATCH_SIZE, cnt - i);
    if (ctx->check_addr33) addr33_batch(hs33, cp + i, batch_size);
    if (ctx->check_addr65) addr65_batch(hs65, cp + i, batch_size);

    for (size_t j = 0; j < HASH_BATCH_SIZE; ++j) {
      if (ctx->check_addr33 && ctx_check_hash(ctx, hs33[j])) {
        // pk_verify_hash(pk[i + j], hs33[j], true, 0);
        ctx_write_found(ctx, "addr33", hs33[j], pk[i + j]);
      }

      if (ctx->check_addr65 && ctx_check_hash(ctx, hs65[j])) {
        // pk_verify_hash(pk[i + j], hs65[j], false, 0);
        ctx_write_found(ctx, "addr65", hs65[j], pk[i + j]);
      }
    }
  }
}

typedef struct cmd_mul_job_t {
  size_t count;
  char lines[GROUP_INV_SIZE][MAX_LINE_SIZE];
} cmd_mul_job_t;

void *cmd_mul_worker(void *arg) {
  ctx_t *ctx = (ctx_t *)arg;

  // sha256 routine
  u8 msg[(MAX_LINE_SIZE + 63 + 9) / 64 * 64] = {0}; // 9 = 1 byte 0x80 + 8 byte bitlen
  u32 res[8] = {0};

  fe pk[GROUP_INV_SIZE];
  pe cp[GROUP_INV_SIZE];
  cmd_mul_job_t *job = NULL;

  while (true) {
    if (job != NULL) free(job);
    job = queue_get(&ctx->queue);
    if (job == NULL) break;

    // parse private keys from hex string
    if (!ctx->raw_text) {
      for (size_t i = 0; i < job->count; ++i) fe_modn_from_hex(pk[i], job->lines[i]);
    } else {
      for (size_t i = 0; i < job->count; ++i) {
        size_t len = strlen(job->lines[i]);
        size_t msg_size = (len + 63 + 9) / 64 * 64;

        // calculate sha256 hash
        size_t bitlen = len * 8;
        memcpy(msg, job->lines[i], len);
        memset(msg + len, 0, msg_size - len);
        msg[len] = 0x80;
        for (int j = 0; j < 8; j++) msg[msg_size - 1 - j] = bitlen >> (j * 8);
        sha256_final(res, (u8 *)msg, msg_size);

        // debug log (do with `-t 1`)
        // printf("\n%zu %s\n", len, job->lines[i]);
        // for (int i = 0; i < msg_size; i++) printf("%02x%s", msg[i], i % 16 == 15 ? "\n" : " ");
        // for (int i = 0; i < 8; i++) printf("%08x%s", res[i], i % 8 == 7 ? "\n" : "");

        pk[i][0] = (u64)res[6] << 32 | res[7];
        pk[i][1] = (u64)res[4] << 32 | res[5];
        pk[i][2] = (u64)res[2] << 32 | res[3];
        pk[i][3] = (u64)res[0] << 32 | res[1];
      }
    }

    // compute public keys in batch
    for (size_t i = 0; i < job->count; ++i) ec_gtable_mul(&cp[i], pk[i]);
    ec_jacobi_grprdc(cp, job->count);

    check_found_mul(ctx, pk, cp, job->count);
    ctx_update(ctx, job->count);
  }

  if (job != NULL) free(job);
  return NULL;
}

void cmd_mul(ctx_t *ctx) {
  ec_gtable_init();

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_create(&ctx->threads[i], NULL, cmd_mul_worker, ctx);
  }

  cmd_mul_job_t *job = calloc(1, sizeof(cmd_mul_job_t));
  char line[MAX_LINE_SIZE];

  while (fgets(line, sizeof(line), stdin) != NULL) {
    size_t len = strlen(line);
    if (len && line[len - 1] == '\n') line[--len] = '\0';
    if (len && line[len - 1] == '\r') line[--len] = '\0';
    if (len == 0) continue;

    strcpy(job->lines[job->count++], line);
    if (job->count == GROUP_INV_SIZE) {
      queue_put(&ctx->queue, job);
      job = calloc(1, sizeof(cmd_mul_job_t));
    }
  }

  if (job->count > 0 && job->count != GROUP_INV_SIZE) {
    queue_put(&ctx->queue, job);
  }

  queue_done(&ctx->queue);

  for (size_t i = 0; i < ctx->threads_count; ++i) {
    pthread_join(ctx->threads[i], NULL);
  }

  ctx_finish(ctx);
}

// MARK: CMD_RND

void gen_random_range(ctx_t *ctx, const fe a, const fe b) {
  // Pure random mode: generate small chunk around random key for thread distribution
  if (ctx->ord_size == 0) {
    fe_rand_range(ctx->range_s, a, b, !ctx->has_seed);
    fe_clone(ctx->range_e, ctx->range_s);
    
    // Create a small range for thread distribution (threads_count * job_size)
    fe chunk_size;
    fe_set64(chunk_size, ctx->threads_count * ctx->job_size);
    fe_modn_add(ctx->range_e, ctx->range_s, chunk_size);
    
    // Keep within bounds
    if (fe_cmp(ctx->range_e, b) > 0) fe_clone(ctx->range_e, b);
    return;
  }

  // Chunked random mode: generate random base with dynamic bits
  fe_rand_range(ctx->range_s, a, b, !ctx->has_seed);
  fe_clone(ctx->range_e, ctx->range_s);
  for (u32 i = ctx->ord_offs; i < (ctx->ord_offs + ctx->ord_size); ++i) {
    ctx->range_s[i / 64] &= ~(1ULL << (i % 64));
    ctx->range_e[i / 64] |= 1ULL << (i % 64);
  }

  // put in bounds
  if (fe_cmp(ctx->range_s, a) <= 0) fe_clone(ctx->range_s, a);
  if (fe_cmp(ctx->range_e, b) >= 0) fe_clone(ctx->range_e, b);
}

void print_range_mask(fe range_s, u32 bits_size, u32 offset, bool use_color) {
  int mask_e = 255 - offset;
  int mask_s = mask_e - bits_size + 1;

  for (int i = 0; i < 64; i++) {
    if (i % 16 == 0 && i != 0) putchar(' ');

    int bits_s = i * 4;
    int bits_e = bits_s + 3;

    u32 fcc = (range_s[(255 - bits_e) / 64] >> ((255 - bits_e) % 64)) & 0xF;
    char cc = "0123456789abcdef"[fcc];

    bool flag = (bits_s >= mask_s && bits_s <= mask_e) || (bits_e >= mask_s && bits_e <= mask_e);
    if (flag) {
      if (use_color) fputs(COLOR_YELLOW, stdout);
      putchar(cc);
      if (use_color) fputs(COLOR_RESET, stdout);
    } else {
      putchar(cc);
    }
  }

  putchar('\n');
}

void cmd_rnd(ctx_t *ctx) {
  ctx->ord_offs = MIN(ctx->ord_offs, 255 - ctx->ord_size);
  // Silent mode - no header output
  
  ctx_precompute_gpoints(ctx);
  ctx->job_size = MAX_JOB_SIZE;
  ctx->ts_started = tsnow(); // actual start time

  fe range_s, range_e;
  fe_clone(range_s, ctx->range_s);
  fe_clone(range_e, ctx->range_e);

  while (true) {
    gen_random_range(ctx, range_s, range_e);
    // Silent mode - no range printing
    ctx_print_status(ctx);

    // if full range is used, skip break after first iteration
    bool is_full = fe_cmp(ctx->range_s, range_s) == 0 && fe_cmp(ctx->range_e, range_e) == 0;

    for (size_t i = 0; i < ctx->threads_count; ++i) {
      pthread_create(&ctx->threads[i], NULL, cmd_add_worker, ctx);
    }

    for (size_t i = 0; i < ctx->threads_count; ++i) {
      pthread_join(ctx->threads[i], NULL);
    }

    // Silent mode - no iteration stats
    
    if (is_full) break;
  }

  ctx_finish(ctx);
}

// MARK: CMD_SCAN (Matrix Scanner with Clean Exit)

void draw_keyhunt_progress_bar(double progress, int width) {
  int filled = (int)(progress * width);
  printf("[");
  for (int i = 0; i < width; i++) {
    if (i < filled) printf("=");
    else printf(" ");
  }
  printf("] %.2f%%", progress * 100);
}

void draw_matrix_scanner(ctx_t *ctx) {
  int64_t effective_time = (int64_t)(ctx->ts_updated - ctx->ts_started) - (int64_t)ctx->paused_time;
  double dt = MAX(1, effective_time) / 1000.0;
  double avg_speed = ctx->k_checked / dt / 1000000;
  
  // Calculate instantaneous speed (last second)
  double instant_speed = 0.0;
  size_t ts = tsnow();
  if (ctx->last_k_timestamp > 0 && (ts - ctx->last_k_timestamp) > 0) {
    double time_diff = (ts - ctx->last_k_timestamp) / 1000.0;
    instant_speed = (ctx->k_checked - ctx->last_k_checked) / time_diff / 1000000;
  }
  
  // Calculate ETA
  double eta_seconds = 0.0;
  if (ctx->scan_total_range > 0 && avg_speed > 0) {
    size_t remaining = ctx->scan_total_range - ctx->k_checked;
    eta_seconds = remaining / (avg_speed * 1000000);
  }
  
  double progress = 0.0;
  if (ctx->scan_total_range > 0) {
    progress = (double)ctx->k_checked / (double)ctx->scan_total_range;
    if (progress > 1.0) progress = 1.0;
  }
  
  // Color coding based on speed
  const char *status_color = "\033[1;32m"; // Green (good)
  const char *status_text = "OPTIMAL";
  if (avg_speed < 0.05) {
    status_color = "\033[1;31m"; // Red (slow)
    status_text = "SLOW";
  } else if (avg_speed < 0.1) {
    status_color = "\033[1;33m"; // Yellow (moderate)
    status_text = "MODERATE";
  }
  
  // Clear screen
  printf("\033[2J\033[H");
  
  // Enhanced header with status
  printf("%s╔═══════════════════════════════════════════════════════════════════╗\033[0m\n", status_color);
  printf("%s║ STATUS: %-10s                                                 ║\033[0m\n", status_color, status_text);
  printf("%s╚═══════════════════════════════════════════════════════════════════╝\033[0m\n\n", status_color);
  
  // Range position display
  if (strlen(ctx->matrix_keys[0]) > 0) {
    printf("RANGE: %016llx%016llx → \033[1;36m%s\033[0m → %016llx%016llx\n\n",
           ctx->range_s[3], ctx->range_s[2],
           ctx->matrix_keys[0] + 32, // Show last 32 chars (current position)
           ctx->range_e[3], ctx->range_e[2]);
  }
  
  // Current scanning key (top display)
  if (strlen(ctx->matrix_keys[0]) > 0) {
    printf("SCANNING KEY: \033[1;37m%s\033[0m\n", ctx->matrix_keys[0]);
  } else {
    printf("SCANNING KEY: initializing...\n");
  }
  
  // Enhanced statistics
  printf("SPEED (AVG): \033[1;32m%.2f\033[0m MKeys/s  |  ", avg_speed);
  printf("SPEED (NOW): \033[1;36m%.2f\033[0m MKeys/s\n", instant_speed);
  printf("TOTAL SCANNED: \033[1;33m%'llu\033[0m keys\n", (unsigned long long)ctx->k_checked);
  
  // ETA display
  if (eta_seconds > 0 && eta_seconds < 86400 * 365) { // Less than 1 year
    int eta_hours = (int)(eta_seconds / 3600);
    int eta_mins = (int)((eta_seconds - eta_hours * 3600) / 60);
    int eta_secs = (int)(eta_seconds - eta_hours * 3600 - eta_mins * 60);
    printf("ETA: \033[1;35m%02d:%02d:%02d\033[0m\n", eta_hours, eta_mins, eta_secs);
  }
  
  printf("\n");
  
  // Matrix scrolling keys with fade
  for (int i = 0; i < 10; i++) {
    if (strlen(ctx->matrix_keys[i]) > 0) {
      int color = 46 - (i * 2);
      printf("\033[38;5;%dm%s\033[0m\n", color, ctx->matrix_keys[i]);
    } else {
      printf("\n");
    }
  }
  
  printf("\n");
  printf("Progress: ");
  draw_keyhunt_progress_bar(progress, 40);
  printf(" | Threads: %zu\n", ctx->threads_count);
  
  fflush(stdout);
  
  // Update last measurement for instantaneous speed
  if ((ts - ctx->last_k_timestamp) >= 1000) { // Update every second
    ctx->last_k_checked = ctx->k_checked;
    ctx->last_k_timestamp = ts;
  }
  
  // Optional logging
  if (ctx->logfile != NULL) {
    fprintf(ctx->logfile, "[%zu] Keys: %llu | Speed: %.2f MKeys/s | Progress: %.2f%%\n",
            ts, (unsigned long long)ctx->k_checked, avg_speed, progress * 100);
    fflush(ctx->logfile);
  }
}

void update_matrix_display(ctx_t *ctx, const fe pk) {
  // Scroll keys down
  for (int i = 9; i > 0; i--) {
    strcpy(ctx->matrix_keys[i], ctx->matrix_keys[i-1]);
  }
  
  // Add new key at top
  snprintf(ctx->matrix_keys[0], 65, "%016llx%016llx%016llx%016llx", 
           pk[3], pk[2], pk[1], pk[0]);
}

void save_session(ctx_t *ctx) {
  if (strlen(ctx->session_file) > 0) {
    FILE *f = fopen(ctx->session_file, "w");
    if (f) {
      fprintf(f, "%016llx%016llx%016llx%016llx\n", 
              ctx->current_scan_pos[3], ctx->current_scan_pos[2],
              ctx->current_scan_pos[1], ctx->current_scan_pos[0]);
      fprintf(f, "%llu\n", (unsigned long long)ctx->k_checked);
      fclose(f);
    }
  }
}

void ctx_scan_update(ctx_t *ctx, size_t k_checked, const fe current_pk) {
  size_t ts = tsnow();
  
  pthread_mutex_lock(&ctx->lock);
  
  ctx->k_checked += k_checked;
  ctx->ts_updated = ts;
  
  // Store current position for session persistence
  fe_clone(ctx->current_scan_pos, current_pk);
  
  // Update matrix display at controlled rate (100ms = 10 FPS target)
  if ((ts - ctx->ts_printed) >= 100) {
    update_matrix_display(ctx, current_pk);
    ctx->ts_printed = ts;
    draw_matrix_scanner(ctx);
    
    // Save session periodically (every update)
    save_session(ctx);
  }
  
  // ATOMIC: Set finished flag immediately if key found (still within mutex)
  if (ctx->k_found > 0) {
    ctx->finished = true;
  }
  
  pthread_mutex_unlock(&ctx->lock);
  
  ctx_check_paused(ctx);
}

void check_found_scan(ctx_t *ctx, fe const start_pk, const pe *points) {
  h160_t hs33[HASH_BATCH_SIZE];
  h160_t hs65[HASH_BATCH_SIZE];

  for (size_t i = 0; i < GROUP_INV_SIZE; i += HASH_BATCH_SIZE) {
    if (ctx->check_addr33) addr33_batch(hs33, points + i, HASH_BATCH_SIZE);
    if (ctx->check_addr65) addr65_batch(hs65, points + i, HASH_BATCH_SIZE);
    for (size_t j = 0; j < HASH_BATCH_SIZE; ++j) {
      if (ctx->check_addr33) check_hash(ctx, true, hs33[j], start_pk, i + j, 0);
      if (ctx->check_addr65) check_hash(ctx, false, hs65[j], start_pk, i + j, 0);
      
      // Stop immediately if key found
      if (ctx->stop_on_found && ctx->k_found > 0) {
        return;
      }
    }
  }

  if (!ctx->use_endo) return;

  size_t esize = HASH_BATCH_SIZE * 5;
  pe endos[esize];
  for (size_t i = 0; i < esize; ++i) fe_set64(endos[i].z, 1);

  size_t ci = 0;
  for (size_t k = 0; k < GROUP_INV_SIZE; ++k) {
    size_t idx = (k * 5) % esize;

    fe_clone(endos[idx + 0].x, points[k].x);
    fe_modp_neg(endos[idx + 0].y, points[k].y);

    fe_modp_mul(endos[idx + 1].x, points[k].x, B1);
    fe_clone(endos[idx + 1].y, points[k].y);

    fe_clone(endos[idx + 2].x, endos[idx + 1].x);
    fe_clone(endos[idx + 2].y, endos[idx + 0].y);

    fe_modp_mul(endos[idx + 3].x, points[k].x, B2);
    fe_clone(endos[idx + 3].y, points[k].y);

    fe_clone(endos[idx + 4].x, endos[idx + 3].x);
    fe_clone(endos[idx + 4].y, endos[idx + 0].y);

    bool is_full = (idx + 5) % esize == 0 || k == GROUP_INV_SIZE - 1;
    if (!is_full) continue;

    for (size_t i = 0; i < esize; i += HASH_BATCH_SIZE) {
      if (ctx->check_addr33) addr33_batch(hs33, endos + i, HASH_BATCH_SIZE);
      if (ctx->check_addr65) addr65_batch(hs65, endos + i, HASH_BATCH_SIZE);

      for (size_t j = 0; j < HASH_BATCH_SIZE; ++j) {
        if (ctx->check_addr33) check_hash(ctx, true, hs33[j], start_pk, ci / 5, (ci % 5) + 1);
        if (ctx->check_addr65) check_hash(ctx, false, hs65[j], start_pk, ci / 5, (ci % 5) + 1);
        ci += 1;
        
        // Stop immediately if key found
        if (ctx->stop_on_found && ctx->k_found > 0) {
          return;
        }
      }
    }
  }

  assert(ci == GROUP_INV_SIZE * 5);
}

void batch_scan(ctx_t *ctx, const fe pk, const size_t iterations) {
  size_t hsize = GROUP_INV_SIZE / 2;

  pe bp[GROUP_INV_SIZE];
  fe dx[hsize];
  pe GStart;
  fe ck, rx, ry;
  fe ss, dd;

  fe_modn_add_stride(ss, pk, ctx->stride_k, hsize);
  ec_jacobi_mulrdc(&GStart, &G1, ss);

  fe_clone(ck, pk);

  size_t counter = 0;
  while (counter < iterations) {
    // CHECK STOP FLAG BEFORE EVERY ITERATION - immediate exit
    if (ctx->finished) return;
    
    for (size_t i = 0; i < hsize; ++i) fe_modp_sub(dx[i], ctx->gpoints[i].x, GStart.x);
    fe_modp_grpinv(dx, hsize);

    pe_clone(&bp[hsize + 0], &GStart);

    for (size_t D = 0; D < 2; ++D) {
      bool positive = D == 0;
